// Generated by Gemini 2.5 Flash & Gemini 3 Pro

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Generates an IcoSphere mesh and applies UV coordinates suitable for an
/// equirectangular (latitude/longitude) texture map.
/// </summary>
[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class IcoSphereGenerator : MonoBehaviour
{
    [Tooltip("The number of times to subdivide the base Icosahedron.")]
    [Range(0, 5)]
    public int recursionLevel = 3;

    [Tooltip("The radius of the generated sphere.")]
    public float radius = 1.0f;

    [ContextMenu("Generate IcoSphere")]
    void Start()
    {
        GenerateIcoSphere();
    }

    void GenerateIcoSphere()
    {
        MeshFilter meshFilter = GetComponent<MeshFilter>();
        Mesh mesh = new Mesh();
        meshFilter.mesh = mesh;

        // --- 1. Initialization ---
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        Dictionary<long, int> middlePointIndexCache = new Dictionary<long, int>();
        
        // Final lists for the actual mesh data
        List<Vector3> finalVertices = new List<Vector3>();
        List<int> finalTriangles = new List<int>();
        List<Vector2> finalUVs = new List<Vector2>();
        List<Vector3> finalNormals = new List<Vector3>(); // NEW: Manually calculating normals

        // --- 2. Create Base Icosahedron (20-sided solid) ---
        float t = (1.0f + Mathf.Sqrt(5.0f)) / 2.0f;

        vertices.Add(new Vector3(-1, t, 0).normalized * radius);
        vertices.Add(new Vector3(1, t, 0).normalized * radius);
        vertices.Add(new Vector3(-1, -t, 0).normalized * radius);
        vertices.Add(new Vector3(1, -t, 0).normalized * radius);

        vertices.Add(new Vector3(0, -1, t).normalized * radius);
        vertices.Add(new Vector3(0, 1, t).normalized * radius);
        vertices.Add(new Vector3(0, -1, -t).normalized * radius);
        vertices.Add(new Vector3(0, 1, -t).normalized * radius);

        vertices.Add(new Vector3(t, 0, -1).normalized * radius);
        vertices.Add(new Vector3(t, 0, 1).normalized * radius);
        vertices.Add(new Vector3(-t, 0, -1).normalized * radius);
        vertices.Add(new Vector3(-t, 0, 1).normalized * radius);

        // 20 faces
        triangles.Add(0); triangles.Add(11); triangles.Add(5);
        triangles.Add(0); triangles.Add(5); triangles.Add(1);
        triangles.Add(0); triangles.Add(1); triangles.Add(7);
        triangles.Add(0); triangles.Add(7); triangles.Add(10);
        triangles.Add(0); triangles.Add(10); triangles.Add(11);

        triangles.Add(1); triangles.Add(5); triangles.Add(9);
        triangles.Add(5); triangles.Add(11); triangles.Add(4);
        triangles.Add(11); triangles.Add(10); triangles.Add(2);
        triangles.Add(10); triangles.Add(7); triangles.Add(6);
        triangles.Add(7); triangles.Add(1); triangles.Add(8);

        triangles.Add(3); triangles.Add(9); triangles.Add(4);
        triangles.Add(3); triangles.Add(4); triangles.Add(2);
        triangles.Add(3); triangles.Add(2); triangles.Add(6);
        triangles.Add(3); triangles.Add(6); triangles.Add(8);
        triangles.Add(3); triangles.Add(8); triangles.Add(9);

        triangles.Add(4); triangles.Add(9); triangles.Add(5);
        triangles.Add(2); triangles.Add(4); triangles.Add(11);
        triangles.Add(6); triangles.Add(2); triangles.Add(10);
        triangles.Add(8); triangles.Add(6); triangles.Add(7);
        triangles.Add(9); triangles.Add(8); triangles.Add(1);

        // --- 3. Subdivide Triangles ---
        for (int i = 0; i < recursionLevel; i++)
        {
            List<int> nextTriangles = new List<int>();
            for (int j = 0; j < triangles.Count; j += 3)
            {
                int i1 = triangles[j];
                int i2 = triangles[j + 1];
                int i3 = triangles[j + 2];

                int m12 = GetMiddlePoint(i1, i2, vertices, middlePointIndexCache, radius);
                int m23 = GetMiddlePoint(i2, i3, vertices, middlePointIndexCache, radius);
                int m31 = GetMiddlePoint(i3, i1, vertices, middlePointIndexCache, radius);

                nextTriangles.Add(i1); nextTriangles.Add(m12); nextTriangles.Add(m31);
                nextTriangles.Add(i2); nextTriangles.Add(m23); nextTriangles.Add(m12);
                nextTriangles.Add(i3); nextTriangles.Add(m31); nextTriangles.Add(m23);
                nextTriangles.Add(m12); nextTriangles.Add(m23); nextTriangles.Add(m31);
            }
            triangles = nextTriangles;
        }

        // --- 4. UV & Seam Correction & Manual Normals ---
        for (int i = 0; i < triangles.Count; i += 3)
        {
            int i1 = triangles[i];
            int i2 = triangles[i + 1];
            int i3 = triangles[i + 2];

            Vector3 v1 = vertices[i1];
            Vector3 v2 = vertices[i2];
            Vector3 v3 = vertices[i3];

            Vector2 uv1 = CalculateEquirectangularUV(v1);
            Vector2 uv2 = CalculateEquirectangularUV(v2);
            Vector2 uv3 = CalculateEquirectangularUV(v3);

            // Check for poles (vertices at y=1 or y=-1)
            // Using a threshold because of floating point precision
            bool p1 = Mathf.Abs(v1.normalized.y) > 0.999f;
            bool p2 = Mathf.Abs(v2.normalized.y) > 0.999f;
            bool p3 = Mathf.Abs(v3.normalized.y) > 0.999f;

            // Calculate min/max U only for non-pole vertices
            float minU = 1.0f;
            float maxU = 0.0f;
            bool hasNonPole = false;

            if (!p1) { minU = Mathf.Min(minU, uv1.x); maxU = Mathf.Max(maxU, uv1.x); hasNonPole = true; }
            if (!p2) { minU = Mathf.Min(minU, uv2.x); maxU = Mathf.Max(maxU, uv2.x); hasNonPole = true; }
            if (!p3) { minU = Mathf.Min(minU, uv3.x); maxU = Mathf.Max(maxU, uv3.x); hasNonPole = true; }

            // If a triangle crosses the seam (diff > 0.5), wrap the lower U values
            if (hasNonPole && (maxU - minU) > 0.5f)
            {
                if (!p1 && uv1.x < 0.5f) uv1.x += 1.0f;
                if (!p2 && uv2.x < 0.5f) uv2.x += 1.0f;
                if (!p3 && uv3.x < 0.5f) uv3.x += 1.0f;
            }

            // Fix pole UVs by averaging the neighbors
            // This must be done AFTER seam correction to ensure the pole connects smoothly
            if (p1) uv1.x = (uv2.x + uv3.x) / 2f;
            if (p2) uv2.x = (uv1.x + uv3.x) / 2f;
            if (p3) uv3.x = (uv1.x + uv2.x) / 2f;

            // Add vertices, UVs, and Normals for this triangle
            AddVertexData(v1, uv1, finalVertices, finalUVs, finalNormals);
            finalTriangles.Add(finalVertices.Count - 1);

            AddVertexData(v2, uv2, finalVertices, finalUVs, finalNormals);
            finalTriangles.Add(finalVertices.Count - 1);

            AddVertexData(v3, uv3, finalVertices, finalUVs, finalNormals);
            finalTriangles.Add(finalVertices.Count - 1);
        }

        // --- 5. Assign to Mesh ---
        mesh.vertices = finalVertices.ToArray();
        mesh.triangles = finalTriangles.ToArray();
        mesh.uv = finalUVs.ToArray();
        
        // Assign the manually calculated normals. 
        // This fixes the "crease" or "mirror" lighting artifact at the seam.
        mesh.normals = finalNormals.ToArray(); 
        
        mesh.RecalculateBounds();
        // mesh.RecalculateNormals(); // DO NOT USE - this breaks smooth shading at the seam!
    }

    /// <summary>
    /// Helper to add vertex data including manual normal calculation.
    /// </summary>
    private void AddVertexData(Vector3 pos, Vector2 uv, List<Vector3> verts, List<Vector2> uvs, List<Vector3> norms)
    {
        verts.Add(pos);
        uvs.Add(uv);
        // For a sphere centered at local (0,0,0), the normal is simply the normalized position vector.
        // This ensures perfect smooth shading even if vertices are duplicated/split.
        norms.Add(pos.normalized); 
    }

    private Vector2 CalculateEquirectangularUV(Vector3 v)
    {
        Vector3 norm = v.normalized;
        float u = Mathf.Atan2(norm.z, norm.x) / (2f * Mathf.PI) + 0.5f;
        float vCoord = Mathf.Asin(norm.y) / Mathf.PI + 0.5f;
        return new Vector2(u, vCoord);
    }

    private int GetMiddlePoint(int p1, int p2, List<Vector3> vertices, Dictionary<long, int> cache, float rad)
    {
        bool firstIsSmaller = p1 < p2;
        long smallerIndex = firstIsSmaller ? p1 : p2;
        long greaterIndex = firstIsSmaller ? p2 : p1;
        long key = (smallerIndex << 32) + greaterIndex;

        if (cache.TryGetValue(key, out int index)) return index;

        Vector3 middle = (vertices[p1] + vertices[p2]) / 2.0f;
        int i = vertices.Count;
        vertices.Add(middle.normalized * rad);
        cache.Add(key, i);
        return i;
    }
}
